#!/usr/bin/env node

// Dependencies
var catversions = require('../');
var lib = require('../lib');
var colors = require('colors');
var program = require('commander');
var versionRg = /\d+\.\d+\.\d+/;
var dotRegex = /\.$/;
var path;

// Args parse
program
  .version(require('../package.json').version)
  .option('-s, --sort', 'Sort by dev versions')
  .parse(process.argv);

// Defaults to actual path
path = program.args[0] || '.';

catversions(path, function (err, versions) {
  if (err) {
    throw err;
  }

  var projects = Object.keys(versions);
  var projectsPadding = lib.rightPadding(projects);
  var dev = [];
  var devVersions = {};
  var semVersions;
  var versionsPadding;

  // Get only the semversion format to determine
  // the left padding when printing
  semVersions = projects.map(function mapProjects (project) {
    var projectVersion = versions[project].split(versionRg);

    devVersions[project] = projectVersion[1];

    return versions[project]
      .replace(projectVersion[1], '')
      .replace(dotRegex, '');
  })

  // Get left padding function
  versionsPadding = lib.leftPadding(semVersions);

  if (program.sort) {
    projects = projects
      .filter(function filterProjects (project) {
        var hasDev = !!devVersions[project];

        if (hasDev) {
          dev.push(project);
        }

        return !hasDev;
      })
      .sort();

    dev.sort();
  }

  projects
    .concat(dev)
    .forEach(function logEach (project) {
      var devVersion = devVersions[project];
      var version = versions[project].replace(devVersion, '');
      console.log(projectsPadding(project).cyan + ' ' + versionsPadding(version) + (devVersion && devVersion.length ? devVersion.red : ''));
    });
});
